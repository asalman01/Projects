from myStack import MyStackfrom expressionTreeNode import ConstantNodefrom expressionTreeNode import OperatorNode# Class that implements an expression tree data structureclass MyExpressionTree(object):		# input is a string that contains an infix math expression that ends with an = symbol	# levels keeps track of the number of levels or height of the tree 	# nodes is the stack used to build the tree  	def __init__(self, input):		self.input = input		self.levels = 0		self.nodes = MyStack()		self.build()		def getLevels(self):		return self.levels			def getInput(self):		return self.input			def getRootNode(self):		return self.nodes.getTop()				def resetInput(self, input):		self.input = input		self.levels = 0		self.build()				def printInfo(self):		info = ''		info += 'Levels: '  + str(self.getLevels())  + '\n'		info += 'Input: '   + str(self.getInput())   + '\n'		print(info, end = '')				print('InOrder Traversal:   ', end = '')		self.printInOrder(self.getRootNode())		print()				print('PostOrder Traversal: ', end = '')		self.printPostOrder(self.getRootNode())		print()				print('PreOrder Traversal:  ', end = '')		self.printPreOrder(self.getRootNode())		print()				print('Value of Tree:  ', self.evaluate(self.getRootNode()), end = '')		print()				# recursive method that prints the expression tree using pre-order traversal	# @param root: the rootNode of the expression tree	def printPreOrder(self,root):				# recursive method that prints the expression tree using in-order traversal	# @param root: the rootNode of the expression tree	def printInOrder(self,root):						# recursive method that prints the expression tree using post-order traversal	# @param root: the rootNode of the expression tree			def printPostOrder(self,root):						# recursive method to evaluate the expression tree	# @param root: the rootNode of the expression tree	def evaluate(self,root):				# builds the expression tree using the self.nodes MyStack attribute	# Precondition: the expression tree was initialized with a valid infix expression	# self.input	# Postcondition: Using the helper methods infixToPostfix and isNumber, the nodes 	# stack is properly filled 	def build(self):								# Helper method that returns the post fix notation of the infix input string 	# Precondition: @param input: a string containing only numbers and the math 	# operations +,-,*,/ The string will be in infix notation, for example 2+3*5=, 	# each input expression will NOT contain any whitespace and ends with the = symbol 	# Postcondition: Assuming the input string is a valid infix expression,	# the post fix expression of input is returned with each token separated by whitespace	def infixToPostfix(input):		# stack used to create postfix string		stack = MyStack()				postFixString = ''		nextOperand = ''				i = 0		while input[i] != '=':			# get next operand and add it to the postfix string. 			if input[i].isdigit() or input[i] == '.':				while input[i] != '+' and input[i] != '-' and \					  input[i] != '*' and input[i] != '/' and \					  input[i] != '=' and input[i] != '(' and \					  input[i] != ')':					nextOperand+=input[i]					i+=1								postFixString+=nextOperand				postFixString+=' '				nextOperand = ''			elif input[i] == '(':				stack.push(input[i])				i+=1			elif input[i] == ')':				while stack.getTop() != '(': 					postFixString+=stack.getTop()					postFixString+=" "					stack.pop()							# discard the left parenthesis				stack.pop();					i+=1			else: # the character is an operator				while int(stack.getCount()) !=0 and stack.getTop() != '(' and \			    (MyExpressionTree.getPrecedence(stack.getTop()) >= MyExpressionTree.getPrecedence(input[i])): 										postFixString+=str(stack.getTop())					postFixString+=" "					stack.pop()					stack.push(input[i])				i+=1		#pop rest of operators on the stack		while int(stack.getCount())>0:			postFixString+=stack.getTop()			postFixString+=" "			stack.pop()			return postFixString	# Helper method that returns the precedence order of an arithmetic operator		# Precondition: @param theOperator: one of the following characters + - * /	# Postcondition: returns the precedence of the operator				def getPrecedence(theOperator):		SUB = 0		ADD = 0		DIV = 1		MULT = 1				precedence = 0				if theOperator == '-':			precedence = SUB		elif theOperator == '+':			precedence = ADD		elif theOperator == '/':			precedence = DIV		elif theOperator == '*':			precedence = MULT				return precedence	# Helper method that determines if a string is a floating point number	# Precondition: @param string: a string 	# Postcondition: returns true if the string is a valid floating point number, otherwise	# returns false	def isNumber(string):		try:			float(string)			return True		except ValueError:			return False	